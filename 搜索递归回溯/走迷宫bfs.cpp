#include <stdio.h>

int check(int a, int b);
void show();

int fx[4] = { 1,-1,0,0 };     //四种走法
int fy[4] = { 0,0,-1,1 };

int maze[20][20] = {        //迷宫，1代表墙，-1代表走过了
	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 0,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 0,0,0,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 0,1,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 0,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1 },
	{ 1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0 },
	{ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0 } };

typedef struct
{
	int x;
	int y;
	int pre;
}pos;    //一个位置，包括当前坐标和之前的位置下标

int qh = 0;     //队列首指针
int qe = 1;     //队列尾指针
pos arr[100];   //位置队列

int main()
{
	maze[0][0] = -1;
	arr[1].x = 1;
	arr[1].y = 1;
	arr[1].pre = 0;
	while (qh != qe)    //bfs结束的条件是队列不空
	{
		++qh;   //队首指针+1
		for (int i = 0; i < 4; ++i)   //队首位置的四个方向依次尝试
		{
			int next_x = arr[qh].x + fx[i];    //计算出下一次要走的坐标
			int next_y = arr[qh].y + fy[i];
			if (check(next_x, next_y) == 1)
			{
				++qe;   //尾指针+1
				arr[qe].x = next_x;   //新位置进队列
				arr[qe].y = next_y;
				arr[qe].pre = qh;
				maze[next_x][next_y] = -1;   //标记为已经走过了，也就是这一位置在队列中出现过了
				if (arr[qe].x == 19 && arr[qe].y == 19)   //走完了
				{
					show();
					return 0;
				}
 			}
		}
	}
	printf("无解\n");
	return 0;
}

int check(int a, int b)   //检查是否能走
{
	if (a < 0 || b < 0 || a>19 || b>19)
		return 0;
	if (maze[a][b] == 1 || maze[a][b] == -1)
		return 0;
	return 1;
}

void show()
{
	printf("(%d, %d)", arr[qe].x + 1, arr[qe].y + 1);
	while (arr[qe].pre != 0)
	{
		qe = arr[qe].pre;
		printf("->(%d, %d)", arr[qe].x + 1, arr[qe].y + 1);
	}
}
